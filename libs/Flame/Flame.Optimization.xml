<?xml version="1.0"?>
<doc>
  <assembly>
    <name>Flame.Optimization</name>
  </assembly>
  <members>
    <member name="T:Flame.Optimization.AccessChecker">
      <summary>
 Defines access checking techniques.
 </summary>
    </member>
    <member name="F:Flame.Optimization.AccessChecker.currentType">
      <summary>
 The current type, which is used to access other types, fields and methods.
 </summary>
    </member>
    <member name="F:Flame.Optimization.AccessChecker.invalidAccess">
      <summary>
 Tells if invalid access has been detected.
 </summary>
    </member>
    <member name="T:Flame.Optimization.ConcatBlocksPass">
      <summary>
 A visitor that concatenates blocks that have a 1:1 successor-predecessor
 relationship.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConcatBlocksPass.GetBlock(System.Collections.Generic.Dictionary`2{Flame.Compiler.UniqueTag,Flame.Compiler.Flow.BasicBlock},Flame.Compiler.Flow.FlowGraph,Flame.Compiler.UniqueTag)">
      <summary>
 Preferably gets a block from the results dictionary. If said
 dictionary does not contain any block identified by the given tag,
 then the block is retrieved from the graph.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConcatBlocksPass.HasExactlyOnePredecessor(Flame.Compiler.UniqueTag,Flame.Compiler.Flow.FlowGraph,System.Collections.Generic.IReadOnlyDictionary`2{Flame.Compiler.UniqueTag,System.Collections.Generic.IEnumerable`1{System.Tuple`2{Flame.Compiler.UniqueTag,System.Collections.Generic.IReadOnlyList`1{Flame.Compiler.Variables.SSAVariable}}}})">
      <summary>
 Figures out if the block identified by the given tag has
 exactly one predecessor.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConcatBlocksPass.ConcatBlocks(Flame.Compiler.Flow.BasicBlock,Flame.Compiler.Flow.BasicBlock,Flame.Compiler.Flow.BlockBranch)">
      <summary>
 Concatenates the given blocks.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConcatBlocksPass.ProcessBlock(Flame.Compiler.Flow.FlowGraph,System.Collections.Generic.HashSet`1{Flame.Compiler.UniqueTag},System.Collections.Generic.Dictionary`2{Flame.Compiler.UniqueTag,Flame.Compiler.Flow.BasicBlock},System.Collections.Generic.IReadOnlyDictionary`2{Flame.Compiler.UniqueTag,System.Collections.Generic.IEnumerable`1{System.Tuple`2{Flame.Compiler.UniqueTag,System.Collections.Generic.IReadOnlyList`1{Flame.Compiler.Variables.SSAVariable}}}})">
      <summary>
 Processes a single block in the worklist.
 </summary>
    </member>
    <member name="F:Flame.Optimization.ConcatBlocksPass.ConcatBlocksPassName">
      <summary>
 The pass name for this pass.
 </summary>
    </member>
    <member name="T:Flame.Optimization.ConciseFlowPass">
      <summary>
 Defines a pass that makes control flow more concise.
 This pass will convert low-level constructs (tagged statements) to their
 high-level equivalents, such as 'while' and 'do...while' loops, where
 doing so is the 'natural' thing to do: i.e. it does not change the semantics
 of the original node tree, and encapsulates things like loop conditions
 in their 'logical' positions.
 </summary>
      <remarks>
 Currently, this pass does the following:
   * Convert tagged statements that end in `continue;` into
     `while (true) { ... }` loops.
 TODO:
   * Convert tagged statements that end in `if (Condition) { continue; }`
     into 'do...while' loops.
   * Convert `while (Condition1) { ... }` loops that start with `if (Condition2) { break; }`
     into `while (Condition1 &amp;&amp; !Condition2) { ... }` loops.
 </remarks>
    </member>
    <member name="T:Flame.Optimization.VariableDefinition">
      <summary>
 A data structure that represents an SSA variable definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.VariableDefinition.AddDefinition(Flame.Compiler.IExpression)">
      <summary>
 Registers the given expression as a variable definition.
 </summary>
    </member>
    <member name="P:Flame.Optimization.VariableDefinition.Definitions">
      <summary>
 Gets all definitions for this variable.
 </summary>
    </member>
    <member name="P:Flame.Optimization.VariableDefinition.IsUnknown">
      <summary>
 Checks if this variable's value is unknown.
 </summary>
    </member>
    <member name="P:Flame.Optimization.VariableDefinition.IsConstant">
      <summary>
 Checks if this variable's value is constant.
 </summary>
    </member>
    <member name="P:Flame.Optimization.VariableDefinition.IsVariable">
      <summary>
 Checks if this variable is known to vary.
 </summary>
    </member>
    <member name="P:Flame.Optimization.VariableDefinition.ConstantDefinition">
      <summary>
 Gets this variable's constant definition, assuming it is indeed
 constant. Otherwise, a null reference is returned.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SSAVariableDefFinder">
      <summary>
 A node visitor that finds SSA variable definitions.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SSAVariableDefFinder.Definitions">
      <summary>
 Gets a mapping of variables to definitions, procured by this node
 visitor.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SSAVariableUseFinder">
      <summary>
 A node visitor that finds SSA variables whose values are used.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSAVariableUseFinder.VisitParameter(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Visits the given SSA local variable, which will always be
 a parameter definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSAVariableUseFinder.Visit(Flame.Compiler.Flow.BlockBranch)">
      <summary>
 Visits the given block branch instruction.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SSAVariableUseFinder.UsedVariables">
      <summary>
 Gets the set of variables that have been used by nodes visited
 by this object.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SSAVariableUseFinder.LoadCount">
      <summary>
 Gets a dictionary that maps SSA variables to the number of times
 their values have been loaded.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SSAVariableUseFinder.ArgumentVariables">
      <summary>
 Gets the set of all variables that are known to be used as arguments.
 </summary>
    </member>
    <member name="T:Flame.Optimization.IgnoredBranch">
      <summary>
 Defines a data structure that represents a (potentially)
 ignored branch.
 </summary>
    </member>
    <member name="P:Flame.Optimization.IgnoredBranch.HasChased">
      <summary>
 Gets a boolean value that tells whether this branch has been
 chased yet.
 </summary>
    </member>
    <member name="P:Flame.Optimization.IgnoredBranch.Branch">
      <summary>
 Gets the actual branch that is (potentially) ignored.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConstantPropagationData.IsPropagateAlwaysTypeCore(Flame.IType)">
      <summary>
 Checks if the given type is a propagate-always type, which can
 safely be propagated anywhere.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConstantPropagationData.IsPropagateAlwaysType(Flame.IType)">
      <summary>
 Checks if the given type is a propagate-always type, which can
 safely be propagated anywhere.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConstantPropagationData.IsLiteralExpression(Flame.Compiler.IExpression)">
      <summary>
 Checks if the given expression is a literal, which can always
 be propagated.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConstantPropagationData.Evaluate(Flame.Compiler.IExpression)">
      <summary>
 Tries to evaluate the given expression. If that can't be done,
 null is returned.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConstantPropagationData.AddDefinition(Flame.Compiler.Variables.SSAVariable,Flame.Compiler.IExpression)">
      <summary>
 Adds a definition for this given SSA variable to this
 constant propagation data structure.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConstantPropagationData.ChaseBranch(Flame.Compiler.Flow.BlockBranch)">
      <summary>
 "Chases" the given branch by marking its target block as
 reachable and turning its arguments into definitions for
 the the target block parameters.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConstantPropagationData.IgnoreBranch(Flame.Compiler.Flow.BlockBranch,Flame.Compiler.IExpression)">
      <summary>
 Ignores the given branch for now. It is registered as dependent
 on the SSA variables in its condition expression, which is
 optimistically constant for now.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConstantPropagationData.MarkReachable(Flame.Compiler.UniqueTag)">
      <summary>
 Marks the given tag as reachable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConstantPropagationData.PopBlock">
      <summary>
 Pops a block tag from the CFG worklist.
 </summary>
    </member>
    <member name="P:Flame.Optimization.ConstantPropagationData.ConstantReplacingVisitor">
      <summary>
 Gets a node visitor that tries to replace SSA variables loads
 by constant definitions.
 </summary>
    </member>
    <member name="P:Flame.Optimization.ConstantPropagationData.IsDone">
      <summary>
 Checks if this constant propagation pass instance is "done", i.e.
 its CFG worklist has become empty.
 </summary>
    </member>
    <member name="P:Flame.Optimization.ConstantPropagationData.Graph">
      <summary>
 Gets this constant propagation instance's flow graph.
 </summary>
    </member>
    <member name="T:Flame.Optimization.ConstantPropagationPass">
      <summary>
 A pass that implements sparse conditional constant propagation.
 This transformation is applied to control flow graphs in SSA form.
 </summary>
    </member>
    <member name="F:Flame.Optimization.ConstantPropagationPass.ConstantPropagationPassName">
      <summary>
 This pass' name.
 </summary>
    </member>
    <member name="T:Flame.Optimization.IdentityVariableFinder">
      <summary>
 A node visitor that finds all variables that have the identity property,
 i.e. they have a unique address - which means they cannot be
 replaced by SSA variables.
 </summary>
    </member>
    <member name="P:Flame.Optimization.IdentityVariableFinder.IdentityVariables">
      <summary>
 Gets the set of variables encountered by this variable
 finder that have the identity property.
 </summary>
    </member>
    <member name="P:Flame.Optimization.IdentityVariableFinder.IsEligible">
      <summary>
 A delegate that tells whether the user of this class is interested
 in a given variable or not. If this is not the case, then it will
 not be inserted in the identity variables set.
 </summary>
    </member>
    <member name="T:Flame.Optimization.LocalSSAConstructionVisitor">
      <summary>
 A visitor that promotes (normal) variables to SSA variables.
 This particular visitor is intended to be used for a single
 basic block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.LocalSSAConstructionVisitor.AddParameter(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Adds the given SSA local to this block's parameter list.
 </summary>
    </member>
    <member name="M:Flame.Optimization.LocalSSAConstructionVisitor.MapVariable(Flame.Compiler.IVariable,Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Maps the given variable to an SSA local.
 </summary>
    </member>
    <member name="P:Flame.Optimization.LocalSSAConstructionVisitor.ParameterVariables">
      <summary>
 Gets the parameter list for this SSA constructing visitor's
 associated block.
 </summary>
    </member>
    <member name="P:Flame.Optimization.LocalSSAConstructionVisitor.BlockTag">
      <summary>
 Gets this local SSA constructing visitor's associated block tag.
 </summary>
    </member>
    <member name="P:Flame.Optimization.LocalSSAConstructionVisitor.CanPromote">
      <summary>
 A delegate that tests if a given variable can be promoted to
 an SSA variable.
 </summary>
    </member>
    <member name="P:Flame.Optimization.LocalSSAConstructionVisitor.ImportVariable">
      <summary>
 A delegate that "imports" a non-local variable. The variable to
 import and this instance are given.
 </summary>
    </member>
    <member name="M:Flame.Optimization.BranchArgAppendingVisitor.Visit(Flame.Compiler.Flow.BlockBranch)">
      <summary>
 Visits the given block branch instruction.
 </summary>
    </member>
    <member name="T:Flame.Optimization.GlobalSSAConstructionVisitor">
      <summary>
 A visitor that promotes (normal) variables to SSA variables. This
 type of SSA constructing visitor is applied to control-flow graphs.
 </summary>
    </member>
    <member name="M:Flame.Optimization.GlobalSSAConstructionVisitor.CanPromote(Flame.Compiler.IVariable)">
      <summary>
 Tests if the given variable can be promoted to an SSA variable.
 This method also makes sure that this variable is not blacklisted.
 </summary>
    </member>
    <member name="M:Flame.Optimization.GlobalSSAConstructionVisitor.GetExtraArgumentList(Flame.Compiler.UniqueTag,Flame.Compiler.UniqueTag)">
      <summary>
 Gets the extra-argument list for this given source and target
 block combination.
 </summary>
    </member>
    <member name="M:Flame.Optimization.GlobalSSAConstructionVisitor.isSealed(Flame.Compiler.UniqueTag)">
      <summary>
 Checks if the block belonging to the given tag has been sealed.
 </summary>
    </member>
    <member name="M:Flame.Optimization.GlobalSSAConstructionVisitor.sealBlock(Flame.Compiler.UniqueTag)">
      <summary>
 Seals the given block. A block is called 'sealed' when all of its
 predecessors have been filled.
 </summary>
    </member>
    <member name="M:Flame.Optimization.GlobalSSAConstructionVisitor.isFilled(Flame.Compiler.UniqueTag,System.Collections.Generic.Dictionary`2{Flame.Compiler.UniqueTag,System.Tuple`2{Flame.Compiler.IStatement,Flame.Compiler.Flow.BlockFlow}})">
      <summary>
 Checks if the given block has been filled yet. A block is called
 'filled' when its body has been visited, i.e. its locals have
 can rewritten in SSA form.
 </summary>
    </member>
    <member name="M:Flame.Optimization.GlobalSSAConstructionVisitor.canSealBlock(Flame.Compiler.Flow.BasicBlock,System.Collections.Generic.Dictionary`2{Flame.Compiler.UniqueTag,System.Tuple`2{Flame.Compiler.IStatement,Flame.Compiler.Flow.BlockFlow}})">
      <summary>
 Checks if the given basic block can be sealed.
 </summary>
    </member>
    <member name="M:Flame.Optimization.GlobalSSAConstructionVisitor.sealBlocks(System.Collections.Generic.Dictionary`2{Flame.Compiler.UniqueTag,System.Tuple`2{Flame.Compiler.IStatement,Flame.Compiler.Flow.BlockFlow}},Flame.Compiler.Flow.FlowGraph)">
      <summary>
 Seals all blocks that can be sealed at this time.
 </summary>
    </member>
    <member name="M:Flame.Optimization.GlobalSSAConstructionVisitor.fillBlock(Flame.Compiler.Flow.BasicBlock,System.Collections.Generic.Dictionary`2{Flame.Compiler.UniqueTag,System.Tuple`2{Flame.Compiler.IStatement,Flame.Compiler.Flow.BlockFlow}},Flame.Compiler.Flow.FlowGraph)">
      <summary>
 Fills the given block.
 </summary>
    </member>
    <member name="P:Flame.Optimization.GlobalSSAConstructionVisitor.IsEligible">
      <summary>
 A delegate that determines whether a given variable can be
 promoted to an SSA variable - assuming said variable has not been
 blacklisted.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConstructSSAPass.IsEligible(Flame.Compiler.IVariable)">
      <summary>
 Tells if the given variable can be replaced by an SSA variable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConstructSSAPass.CreateSSAVariable(Flame.Compiler.IVariable)">
      <summary>
 Creates a new SSA variable from the given variable's signature.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ConstructSSAPass.GetInnerVariable(Flame.Compiler.IVariable)">
      <summary>
 Gets the given variable's inner variable, which can either be
 the variable itself, or the variable it is bound to, if it is
 a late-bound variable.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SSACopyPropagatingVisitor">
      <summary>
 A node visitor that propagates SSA variable copies, but does not
 detect them.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSACopyPropagatingVisitor.VisitParameter(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Visits the given SSA local variable, which will always be
 a parameter definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSACopyPropagatingVisitor.Visit(Flame.Compiler.Flow.BlockBranch)">
      <summary>
 Visits the given block branch instruction.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SSACopyPropagatingVisitor.Copies">
      <summary>
 A dictionary that maps SSA variables to the SSA variables they
 are copied of.
 </summary>
    </member>
    <member name="T:Flame.Optimization.CopyPropagationPass">
      <summary>
 A pass that propagates SSA variable copies.
 </summary>
    </member>
    <member name="M:Flame.Optimization.CopyPropagationPass.TryGetLoadedVariable(Flame.Compiler.IExpression)">
      <summary>
 Tries to extract the SSA variable that this expression loads.
 </summary>
    </member>
    <member name="M:Flame.Optimization.CopyPropagationPass.GetRecursiveCopy(Flame.Compiler.Variables.SSAVariable,System.Collections.Generic.IReadOnlyDictionary`2{Flame.Compiler.Variables.SSAVariable,Flame.Compiler.Variables.SSAVariable})">
      <summary>
 Finds out which variable the given variable is a copy of,
 recursively.
 </summary>
    </member>
    <member name="M:Flame.Optimization.CopyPropagationPass.FindCopies(System.Collections.Generic.IReadOnlyDictionary`2{Flame.Compiler.Variables.SSAVariable,Flame.Compiler.IExpression})">
      <summary>
 Produces a dictionary of SSA variables that are really just copies
 of another variable.
 </summary>
    </member>
    <member name="F:Flame.Optimization.CopyPropagationPass.CopyPropagationPassName">
      <summary>
 This pass' name.
 </summary>
    </member>
    <member name="T:Flame.Optimization.FirstSourceLocationFinder">
      <summary>
 A node visitor that finds the first source location that contains
 a non-constant expression or non-empty statement.
 </summary>
    </member>
    <member name="P:Flame.Optimization.FirstSourceLocationFinder.FoundLocation">
      <summary>
 Tells if a first source location has been found. FirstLocation
 is null if and only if this evaluates to false.
 </summary>
    </member>
    <member name="P:Flame.Optimization.FirstSourceLocationFinder.FirstLocation">
      <summary>
 The first source location belonging to a non-constant expression
 or a non-empty statement.
 </summary>
    </member>
    <member name="T:Flame.Optimization.DeadBlockEliminationVisitor">
      <summary>
 A flow graph visitor that eliminates dead blocks.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeadBlockEliminationVisitor.#ctor">
      <summary>
 Creates a dead block eliminating visitor that does not
 log anything.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeadBlockEliminationVisitor.#ctor(Flame.Compiler.ICompilerLog,Flame.IMethod)">
      <summary>
 Creates a dead block eliminating visitor that logs warnings about
 the given declaring method to the given log.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeadBlockEliminationVisitor.WarnDeadBlock(Flame.Compiler.Flow.BasicBlock)">
      <summary>
 Emits a warning that informs the user that the given basic
 block is unreachable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeadBlockEliminationVisitor.WarnMissingReturn">
      <summary>
 Emits a warning that advises the user to insert a flow-terminating
 statement, such as a "return".
 </summary>
    </member>
    <member name="P:Flame.Optimization.DeadBlockEliminationVisitor.ShouldLog">
      <summary>
 Tests if this dead block eliminating visitor's compiler log
 is not null, which indicates that logging warnings is expected
 of us if we run into fishy code.
 </summary>
    </member>
    <member name="P:Flame.Optimization.DeadBlockEliminationVisitor.Log">
      <summary>
 Gets this dead block eliminating visitor's associated
 compiler log, which it uses to issue diagnostics.
 </summary>
    </member>
    <member name="P:Flame.Optimization.DeadBlockEliminationVisitor.DeclaringMethod">
      <summary>
 Gets the declaring method.
 </summary>
    </member>
    <member name="T:Flame.Optimization.DeadBlockEliminationPass">
      <summary>
 A pass that eliminates dead blocks from flow graphs. A warning is
 issued for dead blocks that contain non-empty source statements or
 non-constant source expressions.
 </summary>
    </member>
    <member name="F:Flame.Optimization.DeadBlockEliminationPass.DeadBlockEliminationPassName">
      <summary>
 This pass' name string.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SilentDeadBlockEliminationPass">
      <summary>
 A pass that eliminates dead blocks from flow graphs. No diagnostics
 are ever issued by this pass.
 </summary>
    </member>
    <member name="T:Flame.Optimization.DeadStoreEliminatingVisitor">
      <summary>
 A visitor that removed (but does not recognize) dead stores from
 a flow graph.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeadStoreEliminatingVisitor.#ctor(Flame.Compiler.Flow.FlowGraph,System.Collections.Generic.HashSet`1{Flame.Compiler.Variables.SSAVariable})">
      <summary>
 Creates a dead store eliminating visitor from the given
 control flow graph and set of live variables.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeadStoreEliminatingVisitor.VisitParameter(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Visits the given SSA local variable, which will always be
 a parameter definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeadStoreEliminatingVisitor.Visit(Flame.Compiler.Flow.BlockBranch)">
      <summary>
 Visits the given block branch instruction.
 </summary>
    </member>
    <member name="P:Flame.Optimization.DeadStoreEliminatingVisitor.Graph">
      <summary>
 Gets the flow graph this visitor is removing dead stores from.
 </summary>
    </member>
    <member name="P:Flame.Optimization.DeadStoreEliminatingVisitor.LiveVariables">
      <summary>
 Gets the set of live variables in this dead store eliminating
 visitor's flow graph.
 </summary>
    </member>
    <member name="T:Flame.Optimization.DeadStoreEliminationPass">
      <summary>
 A pass that eliminates SSA variable definitions that are never used.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeadStoreEliminationPass.MarkLive(Flame.Compiler.Variables.SSAVariable,System.Collections.Generic.HashSet`1{Flame.Compiler.Variables.SSAVariable},System.Collections.Generic.Dictionary`2{Flame.Compiler.Variables.SSAVariable,System.Collections.Generic.HashSet`1{Flame.Compiler.Variables.SSAVariable}})">
      <summary>
 Adds the given variable to the set of used variables.
 If this variable depends on any other variables, then those
 are marked as used, too.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeadStoreEliminationPass.GetLiveVariables(Flame.Compiler.Flow.FlowGraph)">
      <summary>
 Computes the set of live variables in the given flow graph.
 </summary>
    </member>
    <member name="F:Flame.Optimization.DeadStoreEliminationPass.DeadStoreEliminationPassName">
      <summary>
 This pass' name.
 </summary>
    </member>
    <member name="T:Flame.Optimization.LinearLabelFlowBuilder">
      <summary>
 A class that constructs a fairly linear tree of instructions
 that use branches to model basic block flow.
 </summary>
    </member>
    <member name="M:Flame.Optimization.LinearLabelFlowBuilder.HasPlaced(Flame.Compiler.UniqueTag)">
      <summary>
 Gets a boolean value that tells whether the basic block with
 the given tag has been placed yet or not.
 </summary>
    </member>
    <member name="M:Flame.Optimization.LinearLabelFlowBuilder.GetLabel(Flame.Compiler.UniqueTag)">
      <summary>
 Gets the label that belongs to the given tag.
 </summary>
    </member>
    <member name="M:Flame.Optimization.LinearLabelFlowBuilder.EmitStatement(Flame.Compiler.IStatement)">
      <summary>
 Adds the given statement to the statement tree.
 </summary>
    </member>
    <member name="M:Flame.Optimization.LinearLabelFlowBuilder.EmitBranch(Flame.Compiler.UniqueTag,Flame.Compiler.IExpression)">
      <summary>
 Adds a conditional branch to the given block to the statement tree.
 </summary>
    </member>
    <member name="M:Flame.Optimization.LinearLabelFlowBuilder.EmitBranch(Flame.Compiler.UniqueTag)">
      <summary>
 Adds an unconditional branch to the given block to the statement tree.
 </summary>
    </member>
    <member name="M:Flame.Optimization.LinearLabelFlowBuilder.PlaceBlock(Flame.Compiler.Flow.BasicBlock)">
      <summary>
 Places the given block's contents in the statement tree.
 Its location is marked with a label, which allows branches to use it
 as a target.
 </summary>
    </member>
    <member name="P:Flame.Optimization.LinearLabelFlowBuilder.Result">
      <summary>
 Gets the generated statement tree.
 </summary>
    </member>
    <member name="T:Flame.Optimization.DeconstructFlowGraphPass">
      <summary>
 A pass that deconstructs control-flow graphs into a tree
 of instructions that include labels and branches.
 This is suitable for back-ends that support branch instructions.
 </summary>
      <remarks>
 The SSA deconstruction pass is run on the flow graph before it
 is lowered to an instruction tree.
 </remarks>
    </member>
    <member name="M:Flame.Optimization.DeconstructFlowGraphPass.EmitJumpToBlock(Flame.Compiler.UniqueTag,Flame.Compiler.Flow.FlowGraph,Flame.Optimization.LinearLabelFlowBuilder)">
      <summary>
 Emits a "jump" to the given block. This method will try to
 simulate jumps with fallthrough whenever possible.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SSALivenessData">
      <summary>
 Contains all SSA local variable liveness data for a single block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSALivenessData.RegisterDefinition(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Registers a definition action for the given variable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSALivenessData.RegisterAccess(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Registers a get-value action for the given variable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSALivenessData.MarkImport(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Marks the given variable as "imported", which means that
 it is defined elsewhere.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSALivenessData.MarkParameter(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Marks the given variable as a parameter: a locally defined
 variable that is assigned in parallel with the other parameters.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSALivenessData.MarkArgument(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Marks the given variable as an argument for this block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSALivenessData.MarkExport(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 "Exports" the given variable: its final access it set to the
 maximal value, which basically makes it immortal within the
 context of this block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSALivenessData.Defines(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Checks if this block defines the given variable locally, i.e.
 it is defined within the block's body, or it is one of the block's
 parameters.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSALivenessData.DefinesOrImports(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Checks if this block defines or imports the given variable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSALivenessData.GetDefinitionIndex(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Gets an index that describes the point at which the given variable
 is defined.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSALivenessData.GetLastAccessIndex(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Gets an index that describes the point at which the given variable
 is accessed for the last time.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSALivenessData.IsLive(Flame.Compiler.Variables.SSAVariable,System.Int32)">
      <summary>
 Checks if the given variable is live at the given point in execution,
 which is encoded as an integer.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SSALivenessData.UsedVariables">
      <summary>
 Gets the set of all variables whose values are loaded by this block.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SSALiveRangeVisitor">
      <summary>
 A node visitor that discovers live ranges.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SSAGraphLiveness">
      <summary>
 A data structure that contains live ranges for a control-flow graph,
 as well as a related variable map.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SSAGraphLiveness.GetRelatedVariables(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Gets the given variable's set of related variables.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SSAGraphLiveness.LiveRanges">
      <summary>
 Gets the graph's block tag - live ranges map.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SSAGraphLiveness.DefinitionBlocks">
      <summary>
 Gets a dictionary that maps SSA variables to their set of definition
 points, which are either assignments, or arguments.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SSAGraphLiveness.Related">
      <summary>
 Gets the graph's related variable set map.
 Coalescing these variables should result in less variable copying.
 </summary>
    </member>
    <member name="T:Flame.Optimization.DeconstructSSAPass">
      <summary>
 Defines a pass that deconstructs SSA form.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeconstructSSAPass.PropagateImport(Flame.Compiler.UniqueTag,Flame.Compiler.Variables.SSAVariable,System.Collections.Generic.IReadOnlyDictionary`2{Flame.Compiler.UniqueTag,System.Collections.Generic.IEnumerable`1{System.Tuple`2{Flame.Compiler.UniqueTag,System.Collections.Generic.IReadOnlyList`1{Flame.Compiler.Variables.SSAVariable}}}},System.Collections.Generic.Dictionary`2{Flame.Compiler.UniqueTag,Flame.Optimization.SSALivenessData})">
      <summary>
 Checks if the live range for the block with the given tag defines
 or imports the given SSA variable. If not, then that variable is
 imported, and this method is applied recursively to its
 predecessor blocks.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeconstructSSAPass.ComputeLiveness(Flame.Compiler.Flow.FlowGraph)">
      <summary>
 Computes live ranges, as well as related variables, for the given
 flow graph.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeconstructSSAPass.IsLiveAtDef(Flame.Compiler.Variables.SSAVariable,Flame.Compiler.Variables.SSAVariable,Flame.Optimization.SSAGraphLiveness)">
      <summary>
 Checks if the first variable is live at any of the definition
 points of the second variable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeconstructSSAPass.LivenessIntersects(Flame.Compiler.Variables.SSAVariable,Flame.Compiler.Variables.SSAVariable,Flame.Optimization.SSAGraphLiveness)">
      <summary>
 Checks if the liveness of the given variables intersects.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeconstructSSAPass.CanCoalesce(Flame.Compiler.IVariable,Flame.Compiler.Variables.SSAVariable,System.Collections.Generic.HashSet`1{Flame.Compiler.Variables.SSAVariable},Flame.Optimization.SSAGraphLiveness)">
      <summary>
 Checks if the given variable can share the given register with the
 given set of already-allocated variables.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeconstructSSAPass.HasIntersectionElements(System.Collections.Generic.HashSet`1{Flame.Compiler.Variables.SSAVariable},System.Collections.Generic.HashSet`1{Flame.Compiler.Variables.SSAVariable})">
      <summary>
 Checks if the intersection of the given sets is nonempty.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeconstructSSAPass.AllocateRegisters(Flame.Compiler.Flow.FlowGraph)">
      <summary>
 Performs register allocation on the given flow graph.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeconstructSSAPass.RewriteConditionalBranch(Flame.Compiler.Flow.BlockBranch,Flame.Compiler.Flow.FlowGraph,System.Collections.Generic.IReadOnlyDictionary`2{Flame.Compiler.Variables.SSAVariable,Flame.Compiler.IVariable},Flame.Compiler.Flow.BlockBuilder,System.Collections.Generic.Dictionary`2{Flame.IType,Flame.Compiler.IVariable})">
      <summary>
 Rewrites the given conditional branch so that it doesn't
 take any arguments. A new basic block is
 created if this is deemed necessary.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DeconstructSSAPass.RewriteBlock(Flame.Compiler.Flow.BasicBlock,Flame.Compiler.Flow.FlowGraph,System.Collections.Generic.IReadOnlyDictionary`2{Flame.Compiler.Variables.SSAVariable,Flame.Compiler.IVariable},Flame.Compiler.INodeVisitor,Flame.Compiler.Flow.BlockBuilder,System.Collections.Generic.Dictionary`2{Flame.IType,Flame.Compiler.IVariable})">
      <summary>
 Turns the given block into a parameterless block that performs
 argumentless branches.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SpeculativeFlowState">
      <summary>
 A state for the `FinalFlowRemover` node visitor.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SpeculativeFlowState.#ctor(System.Collections.Generic.IEnumerable`1{Flame.Optimization.SpeculativeStatement},System.Boolean)">
      <summary>
 Creates a new speculative flow state from the given speculative final statements
 and a boolean that signals flow termination.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SpeculativeFlowState.WithStatement(Flame.Optimization.SpeculativeStatement)">
      <summary>
 Creates a new speculative flow state that represents the current state with
 the addition of a speculative statement.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SpeculativeFlowState.RemoveSpeculativeStatements">
      <summary>
 Removes all speculative final statements for this state.
 `false` is returned if no speculative final statements were removed
 (because this state didn't have any), otherwise `true`.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SpeculativeFlowState.Sequence(Flame.Optimization.SpeculativeFlowState)">
      <summary>
 Creates a speculative flow state that represents the sequence of the
 this flow state followed by the give state.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SpeculativeFlowState.HasSpeculativeStatements">
      <summary>
 Determines whether this speculative flow state has any final statements.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SpeculativeFlowState.SpeculativeStatements">
      <summary>
 Gets the speculative final statements for this state.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SpeculativeFlowState.IsTerminated">
      <summary>
 Finds out if this speculative flow state has been terminated.
 </summary>
    </member>
    <member name="T:Flame.Optimization.FinalFlowRemover">
      <summary>
 A visitor that matches control flow statements, such as `break` and `continue`
 at the end of an enclosing control flow statement such as a tagged block, a
 `while` loop, a `do...while` loop or a `for` loop.
 Said enclosing statement is then transformed.
 </summary>
    </member>
    <member name="M:Flame.Optimization.FinalFlowRemover.#ctor(Flame.Compiler.IStatement,System.Boolean(Flame.Compiler.IStatement, Flame.Compiler.IStatement))">
      <summary>
 Creates a new final flow remover from the given enclosing flow
 and a function that matches final flow.
 </summary>
    </member>
    <member name="M:Flame.Optimization.FinalFlowRemover.CreateCollapsedFlow(Flame.Optimization.SpeculativeFlowState,Flame.Optimization.SpeculativeFlowState)">
      <summary>
 Computes the "sum" of a flow state and a control flow delta.
 </summary>
    </member>
    <member name="M:Flame.Optimization.FinalFlowRemover.CreateDeltaFlow(Flame.Optimization.SpeculativeFlowState,Flame.Optimization.SpeculativeFlowState)">
      <summary>
 Computes the "difference" between two flow states, such that
 the "sum" of the first flow state and the result of this operation
 results in the second state.
 </summary>
    </member>
    <member name="M:Flame.Optimization.FinalFlowRemover.CreateSequenceFlow(Flame.Optimization.SpeculativeFlowState,Flame.Optimization.SpeculativeFlowState)">
      <summary>
 Creates a flow delta that represents the sequential execution of
 two flow deltas.
 </summary>
    </member>
    <member name="M:Flame.Optimization.FinalFlowRemover.CreateSelectFlow(Flame.Optimization.SpeculativeFlowState,Flame.Optimization.SpeculativeFlowState)">
      <summary>
 Creates a flow delta that represents selecting precisely one of two
 flow deltas.
 </summary>
    </member>
    <member name="M:Flame.Optimization.FinalFlowRemover.CreateLoopFlow(Flame.Compiler.UniqueTag,Flame.Optimization.SpeculativeFlowState)">
      <summary>
 Creates a flow delta that will be executed zero or more
 times.
 </summary>
    </member>
    <member name="P:Flame.Optimization.FinalFlowRemover.TerminatedFlow">
      <summary>
 Gets a flow delta that represents flow termination:
 sequential flow that succeeds it will never be executed.
 </summary>
    </member>
    <member name="P:Flame.Optimization.FinalFlowRemover.EnclosingFlow">
      <summary>
 Gets the final flow remover's enclosing flow statement.
 </summary>
    </member>
    <member name="P:Flame.Optimization.FinalFlowRemover.MatchesInnerFlow">
      <summary>
 Matches the speculative flow statement.
 This delegate's first argument represents the enclosing statement,
 whereas the second argument represents the potential speculative flow statement.
 </summary>
    </member>
    <member name="P:Flame.Optimization.FinalFlowRemover.CurrentFlow">
      <summary>
 Gets or sets the current flow state.
 </summary>
    </member>
    <member name="T:Flame.Optimization.FlattenInitializationVisitor">
      <summary>
 A node visitor that attempts to flatten initialization expressions, by
 moving them higher up the node tree.
 </summary>
      <remarks>
 This can benefit node trees such as:

     #invoke({ init; expr }, args...)

 which will be transformed into the semantically equivalent:

     { init; #invoke(expr, args) }

 In many ways, this visitor is a less demanding version of
 -fimperative-code's visitor.
 </remarks>
    </member>
    <member name="M:Flame.Optimization.FlattenInitializationVisitor.SpillFinalization">
      <summary>
 Spills finalization statements.
 </summary>
    </member>
    <member name="P:Flame.Optimization.FlattenInitializationVisitor.TransformedLocations">
      <summary>
 Gets the source locations belonging to initialization expressions
 that have been moved around in the expression tree.
 </summary>
    </member>
    <member name="T:Flame.Optimization.FlattenInitializationPass">
      <summary>
 A pass that attempts to flatten initialization expressions, by
 moving them higher up the node tree.
 </summary>
    </member>
    <member name="F:Flame.Optimization.FlattenInitializationPass.FlattenInitializationPassName">
      <summary>
 This pass' name string.
 </summary>
    </member>
    <member name="T:Flame.Optimization.ImperativeCodeRewriter">
      <summary>
 A node visitor that rewrites nodes such that they are legal
 for traditional imperative programming languages:
 statements do not appear inside of expressions,
 but expressions may appear inside of statements.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ImperativeCodeRewriter.#ctor">
      <summary>
 Creates a new imperative code rewriter.
 </summary>
    </member>
    <member name="P:Flame.Optimization.ImperativeCodeRewriter.Initialization">
      <summary>
 Gets this imperative code rewriter's initialization statement.
 From an external perspective, this is only useful when rewriting
 top-level expressions.
 </summary>
    </member>
    <member name="P:Flame.Optimization.ImperativeCodeRewriter.Finalization">
      <summary>
 Gets this imperative code rewriter's finalization statement.
 From an external perspective, this is only useful when rewriting
 top-level expressions.
 </summary>
    </member>
    <member name="T:Flame.Optimization.ImperativeCodePass">
      <summary>
 A pass that rewrites statements such that they are legal
 for traditional imperative programming languages:
 statements do not appear inside of expressions,
 but expressions may appear inside of statements.
 </summary>
    </member>
    <member name="F:Flame.Optimization.ImperativeCodePass.ImperativeCodePassName">
      <summary>
 The imperative code pass' name.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InitialFlowState.IsInitial">
      <summary>
 Determines whether this state is "initial": it succeeds the initial
 state directly.
 </summary>
    </member>
    <member name="T:Flame.Optimization.InitialFlowRemover">
      <summary>
 A visitor that matches control flow statements, such as `break` and `continue`
 at the start of an enclosing control flow statement such as a tagged block, a
 `while` loop, a `do...while` loop or a `for` loop.
 Said enclosing statement is then transformed.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InitialFlowRemover.#ctor(Flame.Compiler.IStatement,System.Boolean(Flame.Compiler.IStatement, Flame.Compiler.IStatement))">
      <summary>
 Creates a new final flow remover from the given enclosing flow
 and a function that matches final flow.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InitialFlowRemover.CreateCollapsedFlow(Flame.Optimization.InitialFlowState,Flame.Optimization.InitialFlowState)">
      <summary>
 Computes the "sum" of a flow state and a control flow delta.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InitialFlowRemover.CreateDeltaFlow(Flame.Optimization.InitialFlowState,Flame.Optimization.InitialFlowState)">
      <summary>
 Computes the "difference" between two flow states, such that
 the "sum" of the first flow state and the result of this operation
 results in the second state.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InitialFlowRemover.CreateSequenceFlow(Flame.Optimization.InitialFlowState,Flame.Optimization.InitialFlowState)">
      <summary>
 Creates a flow delta that represents the sequential execution of
 two flow deltas.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InitialFlowRemover.CreateSelectFlow(Flame.Optimization.InitialFlowState,Flame.Optimization.InitialFlowState)">
      <summary>
 Creates a flow delta that represents selecting precisely one of two
 flow deltas.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InitialFlowRemover.CreateLoopFlow(Flame.Compiler.UniqueTag,Flame.Optimization.InitialFlowState)">
      <summary>
 Creates a flow delta that will be executed zero or more
 times.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InitialFlowRemover.TerminatedFlow">
      <summary>
 Gets a flow delta that represents flow termination:
 sequential flow that succeeds it will never be executed.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InitialFlowRemover.EnclosingFlow">
      <summary>
 Gets the final flow remover's enclosing flow statement.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InitialFlowRemover.MatchesInnerFlow">
      <summary>
 Matches the final flow statement.
 This delegate's first argument represents the enclosing statement,
 whereas the second argument represents the potential final flow statement.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InitialFlowRemover.CurrentFlow">
      <summary>
 Gets or sets the current flow state.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InliningExtensions.CanInline(Flame.IMethod,Flame.IType)">
      <summary>
 Finds out whether a call to the given method can be inlined.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InliningExtensions.CanInline(Flame.IMethod,Flame.Compiler.IExpression)">
      <summary>
 Finds out whether a call to the given method can be inlined.
 </summary>
    </member>
    <member name="T:Flame.Optimization.DissectedCall">
      <summary>
 A method call that has been decomposed into a callee, a 'this' object,
 and a sequence of arguments.
 </summary>
    </member>
    <member name="M:Flame.Optimization.DissectedCall.#ctor(Flame.Compiler.IExpression,Flame.IMethod,System.Collections.Generic.IEnumerable`1{Flame.Compiler.IExpression})">
      <summary>
 Creates a new dissected call from the given 'this' value,
 callee, and sequence of arguments.
 </summary>
    </member>
    <member name="P:Flame.Optimization.DissectedCall.ThisValue">
      <summary>
 Gets the expression that produces the 'this' object for
 this call.
 </summary>
    </member>
    <member name="P:Flame.Optimization.DissectedCall.Method">
      <summary>
 Gets the callee of this call.
 </summary>
    </member>
    <member name="P:Flame.Optimization.DissectedCall.Arguments">
      <summary>
 Gets the sequence of arguments that are passed to the
 callee.
 </summary>
    </member>
    <member name="T:Flame.Optimization.InliningPassBase">
      <summary>
 A pass that performs a number of iterations, which consist of
 inlining followed by whole-body optimization.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InliningPassBase.GetInliningCriteria(Flame.Compiler.Visitors.BodyPassArgument)">
      <summary>
 Creates a delegate that determines whether the given dissected
 direct call should be inlined.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InliningPassBase.GetBodyOptimizer(Flame.Compiler.Visitors.BodyPassArgument)">
      <summary>
 Creates a statement optimizer. Note that this should perform
 simple intraprocedural optimizations, rather than more advance
 optimizations, such as inlining.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InliningPassBase.GetMaxRecursion(Flame.Compiler.Visitors.BodyPassArgument)">
      <summary>
 Gets the number of times this pass is allowed to
 inline functions recursively. This corresponds
 to the maximal number of inline-optimize iterations this pass makes.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InliningPassBase.NameMethod(Flame.IMethod)">
      <summary>
 Names the given method. This includes any quotation marks, or other
 delimiters.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InliningPassBase.LogInlinedCall(Flame.Compiler.Visitors.BodyPassArgument,Flame.Compiler.SourceLocation,Flame.Optimization.DissectedCall,System.Int32)">
      <summary>
 Logs a message that proclaims that an inlining operation
 has occurred.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InliningPassBase.Apply(Flame.Compiler.Visitors.BodyPassArgument)">
      <summary>
 Applies this pass to the given body pass argument.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InliningPassBase.InliningRemarksOption">
      <summary>
 The remarks option for inlining: applying this pass to
 a function will emit a message if this is option set to true.
 </summary>
    </member>
    <member name="F:Flame.Optimization.InliningPassBase.InliningPassName">
      <summary>
 Gets the default inlining pass name.
 </summary>
    </member>
    <member name="T:Flame.Optimization.InliningVisitor">
      <summary>
 A visitor that inlines direct calls, if they meet certain criteria.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InliningVisitor.Inline(Flame.Optimization.DissectedCall)">
      <summary>
 Inlines the given dissected call: its arguments and return value
 are replaced by local variables, and control will resume when the
 inlined callee is done. Null is returned if the inlining operation
 could not be performed.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InliningVisitor.CurrentMethod">
      <summary>
 Gets the current method, whose body is being processed.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InliningVisitor.HasInlined">
      <summary>
 Checks if this inlining visitor has inlined anything yet.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InliningVisitor.InlinedCount">
      <summary>
 Gets a read-only dictionary that maps methods to the number
 of times they have been inlined by this visitor.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InliningVisitor.InlinedCallLocations">
      <summary>
 Gets all call locations that have been inlined.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InliningVisitor.PassArgument">
      <summary>
 Gets this visitor's body pass argument.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InliningVisitor.ShouldInline">
      <summary>
 Determines whether the given dissected direct call should be inlined.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InliningVariableVisitor.VisitParameter(Flame.Compiler.Variables.SSAVariable)">
      <summary>
 Visits the given SSA local variable, which will always be
 a parameter definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.InliningVariableVisitor.Visit(Flame.Compiler.Flow.BlockBranch)">
      <summary>
 Visits the given block branch instruction.
 </summary>
    </member>
    <member name="T:Flame.Optimization.JumpThreadingVisitor">
      <summary>
 A branch visitor that tries to replace argumentless indirect branches
 with more direct branches.
 </summary>
    </member>
    <member name="M:Flame.Optimization.JumpThreadingVisitor.#ctor(System.Collections.Generic.IReadOnlyDictionary`2{Flame.Compiler.UniqueTag,Flame.Compiler.Flow.BlockBranch})">
      <summary>
 Creates a jump-threading visitor from the given threaded jumps dictionary.
 </summary>
    </member>
    <member name="P:Flame.Optimization.JumpThreadingVisitor.ThreadedJumps">
      <summary>
 A dictionary that maps block tags to the branch they eventually
 and unambiguously execute.
 </summary>
    </member>
    <member name="T:Flame.Optimization.JumpThreadingPass">
      <summary>
 A pass that applies simple jump threading to flow graphs.
 </summary>
    </member>
    <member name="M:Flame.Optimization.JumpThreadingPass.FlattenIndirectJumps(Flame.Compiler.Flow.FlowGraph)">
      <summary>
 Populates a dictionary with block tags that are really just
 direct jumps, and maps them to their eventual target block.
 </summary>
    </member>
    <member name="F:Flame.Optimization.JumpThreadingPass.JumpThreadingPassName">
      <summary>
 This pass' name.
 </summary>
    </member>
    <member name="T:Flame.Optimization.LambdaCapturedValueVisitor">
      <summary>
 A node visitor that finds out which elements of the captured value
 list are being used in a node, and which are not.
 </summary>
    </member>
    <member name="M:Flame.Optimization.LambdaCapturedValueVisitor.#ctor">
      <summary>
 Creates a new captured value visitor.
 </summary>
    </member>
    <member name="P:Flame.Optimization.LambdaCapturedValueVisitor.UsedCapturedValues">
      <summary>
 Gets the set of used captured value indices.
 </summary>
    </member>
    <member name="T:Flame.Optimization.LambdaCapturedValueRewriter">
      <summary>
 A type of node visitor that modifies the capture list indices of
 captured value expressions.
 </summary>
    </member>
    <member name="M:Flame.Optimization.LambdaCapturedValueRewriter.#ctor(Flame.Compiler.Expressions.LambdaHeader,Flame.Compiler.Expressions.LambdaBoundHeaderBlock,System.Collections.Generic.IReadOnlyDictionary`2{System.Int32,System.Int32})">
      <summary>
 Creates a new captured value rewriter from the given
 captured value index mapping.
 </summary>
    </member>
    <member name="P:Flame.Optimization.LambdaCapturedValueRewriter.CapturedValueMapping">
      <summary>
 Gets a mapping of source captured value indices to target captured
 value indices.
 </summary>
    </member>
    <member name="P:Flame.Optimization.LambdaCapturedValueRewriter.Header">
      <summary>
 Gets the lambda header to use.
 </summary>
    </member>
    <member name="P:Flame.Optimization.LambdaCapturedValueRewriter.BoundHeaderBlock">
      <summary>
 Gets the bound header block to use.
 </summary>
    </member>
    <member name="T:Flame.Optimization.NodeOptimizationPass">
      <summary>
 A pass that calls the `Optimize` method on statements and expression
 nodes.
 </summary>
    </member>
    <member name="F:Flame.Optimization.NodeOptimizationPass.NodeOptimizationPassName">
      <summary>
 This pass' name.
 </summary>
    </member>
    <member name="T:Flame.Optimization.ArgumentRemovingVisitor">
      <summary>
 Defines a branch visitor that removes arguments to trivial parameters.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ArgumentRemovingVisitor.#ctor(Flame.Compiler.Flow.FlowGraph,System.Collections.Generic.IEnumerable`1{Flame.Compiler.Variables.SSAVariable})">
      <summary>
 Creates a trivial argument removing visitor from the given
 control flow graph and marked variable set.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ArgumentRemovingVisitor.Visit(Flame.Compiler.Flow.BlockBranch)">
      <summary>
 Visits the given block branch instruction.
 </summary>
    </member>
    <member name="P:Flame.Optimization.ArgumentRemovingVisitor.Graph">
      <summary>
 Gets the control flow graph this trivial argument removing visitor
 uses to resolve basic block tags.
 </summary>
    </member>
    <member name="P:Flame.Optimization.ArgumentRemovingVisitor.MarkedVariables">
      <summary>
 Gets a set of SSA parameters that have been marked for removal.
 </summary>
    </member>
    <member name="T:Flame.Optimization.RemoveTrivialPhiPass">
      <summary>
 A pass that removes trivial SSA argument/parameter pairs.
 </summary>
    </member>
    <member name="M:Flame.Optimization.RemoveTrivialPhiPass.tryRemoveTrivialPhi(Flame.Compiler.Variables.SSAVariable,System.Collections.Generic.Dictionary`2{Flame.Compiler.Variables.SSAVariable,System.Collections.Generic.HashSet`1{Flame.Compiler.Variables.SSAVariable}},System.Collections.Generic.Dictionary`2{Flame.Compiler.Variables.SSAVariable,System.Collections.Generic.HashSet`1{Flame.Compiler.Variables.SSAVariable}},System.Collections.Generic.Dictionary`2{Flame.Compiler.Variables.SSAVariable,Flame.Compiler.IExpression})">
      <summary>
 Tries to mark trivial SSA local parameters as trivial.
 </summary>
      <remarks>
 The following phi statements are trivial:

     x := phi(y)
     x := phi(x, y)
     x := phi()

 </remarks>
    </member>
    <member name="F:Flame.Optimization.RemoveTrivialPhiPass.RemoveTrivialPhiPassName">
      <summary>
 This pass' name.
 </summary>
    </member>
    <member name="T:Flame.Optimization.ReturnMotionVisitor">
      <summary>
 A visitor that attempts to "push down" return statements.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ReturnMotionVisitor.PushDownReturn(Flame.Compiler.IExpression)">
      <summary>
 Creates a logical return statement, which is pushed down
 as far as possible.
 </summary>
    </member>
    <member name="P:Flame.Optimization.ReturnMotionVisitor.MatchedLocations">
      <summary>
 Gets a sequence of source locations that identify the sites where
 'return' statements were successfully pushed down.
 </summary>
    </member>
    <member name="T:Flame.Optimization.ReturnMotionPass">
      <summary>
 A pass that attempts to "push down" 'return-select', 'return-source-expr' and
 'return-initialized' expressions. Running this pass before applying
 -ftail-recursion should improve the latter's effectiveness, especially
 for expression-based languages.
 </summary>
      <remarks>
 The following transformations are made, which can be recursive:

     return(select(flag, x, y))
 --&gt; if-else(flag, return(x), return(y))

     return(initialized(init, val, {}))
 --&gt; { init, return(val) }

     return(source-expr(val))
 --&gt; source-stmt(return(val))
 </remarks>
    </member>
    <member name="P:Flame.Optimization.ReturnMotionPass.ReturnMotionRemarksOption">
      <summary>
 The remarks option for return motion: applying this pass to
 a function will emit a message if this is option set to true.
 </summary>
    </member>
    <member name="F:Flame.Optimization.ReturnMotionPass.ReturnMotionPassName">
      <summary>
 This pass' name.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SimplifyFlowPass">
      <summary>
 Defines a flow simplification pass: a pass that will simplify control flow statements.
 Applying this pass can simplify the code generated by the back-end,
 and allow other passes to make more accurate predictions about control flow.

 This pass will reduce high-level control flow into lower-level constrol flow,
 usually tagged statements, if it deems said operation possibly profitable, but will not
 attempt to convert low-level control flow into higher-level control flow,
 regardless of the feasibility of the operation.
 </summary>
      <remarks>
 Currently, this pass does the following:
   * Remove final 'break' statements from tagged statements, and then
     try to reduce those to sequential flow.
   * Convert 'while' blocks that end in 'break' statements
     into 'if' blocks wrapped by a tagged statement,
     and try to reduce those to sequential flow.
   * Convert 'do...while' blocks that end in 'break' statements
     into tagged statements, and try to reduce those to sequential flow.
 </remarks>
    </member>
    <member name="T:Flame.Optimization.SimplifySelectFlowPass">
      <summary>
 A pass that simplifies 'select' control flow where the 'select' condition
 can be evaluated at compile-time.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SimplifySelectFlowPass.Simplify(Flame.Compiler.Flow.BasicBlock)">
      <summary>
 Tries to simplify the given basic block's outgoing flow.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SimplifySelectFlowPass.Apply(Flame.Compiler.Flow.FlowGraph)">
      <summary>
 Applies this pass to the given flow graph.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SimplifySelectFlowPass.Apply(Flame.Compiler.IStatement)">
      <summary>
 Recursively applies this pass to the given statement.
 </summary>
    </member>
    <member name="F:Flame.Optimization.SimplifySelectFlowPass.SimplifySelectFlowPassName">
      <summary>
 This pass' name.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SizeVisitor">
      <summary>
 A node visitor that computes an approximate size of a syntax tree.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SizeVisitor.CreateCollapsedFlow(System.Int32,System.Int32)">
      <summary>
 Computes the "sum" of a flow state and a control flow delta.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SizeVisitor.CreateDeltaFlow(System.Int32,System.Int32)">
      <summary>
 Computes the "difference" between two flow states, such that
 the "sum" of the first flow state and the result of this operation
 results in the second state.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SizeVisitor.CreateSequenceFlow(System.Int32,System.Int32)">
      <summary>
 Creates a flow delta that represents the sequential execution of
 two flow deltas.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SizeVisitor.CreateSelectFlow(System.Int32,System.Int32)">
      <summary>
 Selects precisely one of two flow paths.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SizeVisitor.CreateLoopFlow(Flame.Compiler.UniqueTag,System.Int32)">
      <summary>
 Creates a flow state that "loops", i.e. will be executed zero or more
 times.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SizeVisitor.Visit(Flame.Compiler.IExpression)">
      <summary>
 "Visits" an expression: an expression is taken as input and transformed another expression.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SizeVisitor.Visit(Flame.Compiler.IStatement)">
      <summary>
 "Visits" a statement: an statement is taken as input and transformed another statement.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SlimLambdaVisitor">
      <summary>
 A node visitor that attempts that attempts to optimize lambda expressions
 by removing unused expressions from their capture lists.
 Source locations beloning to lambdas that have been optimized are remembered
 by this visitor.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SlimLambdaVisitor.TransformedLocations">
      <summary>
 Gets the source locations belonging to lambda expressions
 that have been optimized by this visitor, followed by their
 old capture list size, and the new capture list size.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SlimLambdaPass">
      <summary>
 A pass that attempts that attempts to optimize lambda expressions
 by removing unused expressions from their capture lists.
 </summary>
    </member>
    <member name="F:Flame.Optimization.SlimLambdaPass.SlimLambdaPassName">
      <summary>
 This pass' name string.
 </summary>
    </member>
    <member name="F:Flame.Optimization.SlimLambdaPass.SlimLambdaTypesRemarkName">
      <summary>
 The remark name that turns on type remarks.
 </summary>
    </member>
    <member name="T:Flame.Optimization.SpeculativeStatement">
      <summary>
 Defines a speculative statement: a statement that can first be defined
 and inserted into the node tree, and later be marked "alive" or "dead".
 "Dead" speculative statements are equivalent to the "dead" inner statement.
 "Alive" speculative statements are equivalent to their "live" inner statement.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SpeculativeStatement.#ctor(Flame.Compiler.IStatement)">
      <summary>
 Creates a speculative statement that corresponds to the given
 inner statement, and is marked "alive".
 </summary>
    </member>
    <member name="M:Flame.Optimization.SpeculativeStatement.#ctor(Flame.Compiler.IStatement,System.Boolean)">
      <summary>
 Creates a speculative statement from the given inner statement and
 a boolean that determines whether it is alive or dead.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SpeculativeStatement.#ctor(Flame.Compiler.IStatement,Flame.Compiler.IStatement)">
      <summary>
 Creates a speculative statement that is marked "alive". Its "live"
 and "dead" inner statements are given.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SpeculativeStatement.LiveContents">
      <summary>
 Gets the speculative statement's inner statement when this statement
 is alive.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SpeculativeStatement.DeadContents">
      <summary>
 Gets this speculative statement's inner statement when this statement
 is dead.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SpeculativeStatement.IsAlive">
      <summary>
 Gets or sets a boolean flag that tells if this speculative statement
 is "alive" or "dead".
 </summary>
    </member>
    <member name="T:Flame.Optimization.SpeculativeExpression">
      <summary>
 The expression equivalent of SpeculativeStatement.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SpeculativeExpression.#ctor(Flame.Compiler.IExpression,Flame.Compiler.IExpression)">
      <summary>
 Creates a speculative expression that is marked "alive". Its "live"
 and "dead" inner statements are given.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SpeculativeExpression.LiveContents">
      <summary>
 Gets the speculative expression's inner expression when this statement
 is alive.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SpeculativeExpression.DeadContents">
      <summary>
 Gets this speculative expression's inner expression when this statement
 is dead.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SpeculativeExpression.IsAlive">
      <summary>
 Gets or sets a boolean flag that tells if this speculative expression
 is "alive" or "dead".
 </summary>
    </member>
    <member name="T:Flame.Optimization.BlockStackIntrinsicsPlacingVisitor">
      <summary>
 A visitor that attempts to replace SSA locals by stack
 intrinsics.
 </summary>
    </member>
    <member name="M:Flame.Optimization.BlockStackIntrinsicsPlacingVisitor.CheckCompleted">
      <summary>
 Checks that this stack intrinsics pass has run to completion.
 This is intended for debug purposes, and need not be called on
 release builds.
 </summary>
    </member>
    <member name="P:Flame.Optimization.BlockStackIntrinsicsPlacingVisitor.Variable">
      <summary>
 Gets the variable to replace by stack intrinsics.
 </summary>
    </member>
    <member name="P:Flame.Optimization.BlockStackIntrinsicsPlacingVisitor.LoadCount">
      <summary>
 Gets the number of this this visitor's associated SSA variable
 is loaded.
 </summary>
    </member>
    <member name="T:Flame.Optimization.StackIntrinsicsPass">
      <summary>
 A pass that tries to replace SSA variables by stack intrinsics.
 </summary>
    </member>
    <member name="M:Flame.Optimization.StackIntrinsicsPass.ComputeBlockLocalVariables(Flame.Compiler.Flow.FlowGraph)">
      <summary>
 Finds all variables in the given flow graph that are used only
 in the block that defines them. The result is a tuple that
 consists of the given values:
     1. A dictionary that maps block-local variables to
        their use count.
     2. A dictionary that maps basic block tags to a set
        of variables that includes the block's
        block-local variables.
 </summary>
    </member>
    <member name="F:Flame.Optimization.StackIntrinsicsPass.StackIntrinsicsPassName">
      <summary>
 This pass' name.
 </summary>
    </member>
    <member name="T:Flame.Optimization.StatementRewriter">
      <summary>
 A visitor that matches and then rewrites statements.
 </summary>
    </member>
    <member name="M:Flame.Optimization.StatementRewriter.#ctor(System.Boolean(Flame.Compiler.IStatement),Flame.Compiler.IStatement(Flame.Compiler.IStatement))">
      <summary>
 Creates a final flow visitor from the given delegates.
 </summary>
    </member>
    <member name="P:Flame.Optimization.StatementRewriter.MatchesStatement">
      <summary>
 Finds out whether a given statement matches a set of criteria.
 </summary>
    </member>
    <member name="P:Flame.Optimization.StatementRewriter.TransformStatement">
      <summary>
 Transforms a matched statement.
 </summary>
    </member>
    <member name="T:Flame.Optimization.TailRecursionVisitor">
      <summary>
 A statement visitor that rewrites tail recursion as iteration.
 Also works for lambdas.
 </summary>
      <remarks>
 Rewrites

 return(invoke(get_delegate(this_method, this|null), arg0, arg1...))

 as

 var temp0 = arg0;
 var temp1 = arg1;
 ...
 var temp(N-1) = arg(N-1);

 paramN = argN;

 param(N-1) = temp(N-1);
 release temp(N-1);
 ...
 param1 = temp1;
 release temp1;
 param0 = temp0;
 release temp0;
 ...
 continue OuterTag;
 </remarks>
    </member>
    <member name="M:Flame.Optimization.TailRecursionVisitor.MatchesSelfCall(Flame.Compiler.IExpression)">
      <summary>
 Determines whether the given expression is a self-call.
 </summary>
    </member>
    <member name="M:Flame.Optimization.TailRecursionVisitor.VisitBody(Flame.Compiler.IExpression,Flame.IMethod)">
      <summary>
 Visits the given expression, which logically belongs to the given method.
 </summary>
    </member>
    <member name="M:Flame.Optimization.TailRecursionVisitor.VisitBody(Flame.Compiler.IStatement,Flame.IMethod)">
      <summary>
 Visits the given statement, which logically belongs to the given method.
 </summary>
    </member>
    <member name="P:Flame.Optimization.TailRecursionVisitor.MatchedLocations">
      <summary>
 Gets a list of all source locations containing tail-recursive calls
 that were optimized.
 </summary>
    </member>
    <member name="P:Flame.Optimization.TailRecursionVisitor.Method">
      <summary>
 Gets the method the tail recursion visitor is being applied
 to.
 </summary>
    </member>
    <member name="P:Flame.Optimization.TailRecursionVisitor.OuterTag">
      <summary>
 Gets the tail recursion visitor's outer block tag.
 </summary>
    </member>
    <member name="P:Flame.Optimization.TailRecursionVisitor.HasReplaced">
      <summary>
 Gets a boolean flag that tells if this tail recursion visitor
 has replaced one or more tail recursive calls with `continue`
 statements.
 </summary>
    </member>
    <member name="T:Flame.Optimization.TailRecursionPass">
      <summary>
 A pass that rewrites tail recursion as iteration.
 </summary>
      <remarks>
 Rewrites

 return(invoke(get_delegate(this_method, this|null), arg0, arg1...))

 as

 var temp0 = arg0;
 var temp1 = arg1;
 ...
 var temp(N-1) = arg(N-1);

 paramN = argN;

 param(N-1) = temp(N-1);
 release temp(N-1);
 ...
 param1 = temp1;
 release temp1;
 param0 = temp0;
 release temp0;
 ...
 continue OuterTag;
 </remarks>
    </member>
    <member name="P:Flame.Optimization.TailRecursionPass.TailRecursionRemarksOption">
      <summary>
 The remarks option for tail recursion: applying this pass to
 a function will emit a message if this is option set to true.
 </summary>
    </member>
    <member name="F:Flame.Optimization.TailRecursionPass.TailRecursionPassName">
      <summary>
 The pass name string for the tail recursion pass.
 </summary>
    </member>
    <member name="T:Flame.Optimization.UnwrapBoundVariablesPass">
      <summary>
 A pass that replaces late bound variables by their contents.
 </summary>
    </member>
    <member name="M:Flame.Optimization.UnwrapBoundVariablesPass.CanSubstituteVariable(Flame.Compiler.IVariable)">
      <summary>
 Determines whether the given variable can be substituted or not.
 </summary>
    </member>
    <member name="M:Flame.Optimization.UnwrapBoundVariablesPass.SubstituteVariable(Flame.Compiler.IVariable)">
      <summary>
 Substitutes the given variable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.UnwrapBoundVariablesPass.Apply(Flame.Compiler.IStatement)">
      <summary>
 Applies this pass to the given statement.
 </summary>
    </member>
    <member name="P:Flame.Optimization.ValuePropagatingVisitor.UseCounts">
      <summary>
 Gets the use counts associated with block-local variables by
 this value propagating visitor.
 </summary>
    </member>
    <member name="T:Flame.Optimization.ValuePropagationPass">
      <summary>
 A pass that propagates block-local SSA variable definitions.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ValuePropagationPass.CanDelayTopLevelExpression(Flame.Compiler.IExpression)">
      <summary>
 Tests if the given top-level expression can be delayed.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ValuePropagationPass.CanDelayTopLevelStatement(Flame.Compiler.IStatement)">
      <summary>
 Tests if the given top-level expression can be delayed.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ValuePropagationPass.IsPropagateAlwaysExpression(Flame.Compiler.IExpression)">
      <summary>
 Tells if this expression is a propagate-always expression:
 an expression that should always be propagated, regardless
 of use count.
 </summary>
    </member>
    <member name="M:Flame.Optimization.ValuePropagationPass.IsPropagateOnceExpression(Flame.Compiler.IExpression)">
      <summary>
 Tells if this expression is a propagate-always expression:
 an expression that should always be propagated, provided
 its use count is one.
 </summary>
    </member>
    <member name="F:Flame.Optimization.ValuePropagationPass.ValuePropagationPassName">
      <summary>
 Gets this pass' name.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.AccessCount">
      <summary>
 Records how many times a variable or variable definition has been accessed.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.AccessCount.#ctor">
      <summary>
 Creates a new access count that represents zero variable accesses.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.AccessCount.#ctor(System.Int32)">
      <summary>
 Creates a new access count that represents the specified number of accesses.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.AccessCount.Add(Flame.Optimization.Variables.AccessCount)">
      <summary>
 Adds this access count to another.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.AccessCount.Multiply(Flame.Optimization.Variables.AccessCount)">
      <summary>
 Multiplies this access count with another.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.AccessCount.IsInfinity">
      <summary>
 Gets a boolean value that tells if this access count is an infinite number.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.AccessCount.Count">
      <summary>
 Gets the number of accesses, provided that this access count is not
 infinite.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.AccessMetrics.MinAccess">
      <summary>
 Gets an approximation of the total access count's lower bound.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.AccessMetrics.MaxAccess">
      <summary>
 Gets an approximation of the total access count's upper bound.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.AccessMetrics.IsDefined">
      <summary>
 Gets a boolean flag that tells if these access metrics' associated
 object has definitely been defined.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.AccessVisitor.CreateCollapsedFlow(System.Collections.Generic.List`1{System.Func`3{Flame.Optimization.Variables.IVariableDefinition,System.Boolean,Flame.Optimization.Variables.AccessMetrics}},System.Collections.Generic.List`1{System.Func`3{Flame.Optimization.Variables.IVariableDefinition,System.Boolean,Flame.Optimization.Variables.AccessMetrics}})">
      <summary>
 Computes the "sum" of a flow state and a control flow delta.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.AccessVisitor.CreateDeltaFlow(System.Collections.Generic.List`1{System.Func`3{Flame.Optimization.Variables.IVariableDefinition,System.Boolean,Flame.Optimization.Variables.AccessMetrics}},System.Collections.Generic.List`1{System.Func`3{Flame.Optimization.Variables.IVariableDefinition,System.Boolean,Flame.Optimization.Variables.AccessMetrics}})">
      <summary>
 Computes the "difference" between two flow states, such that
 the "sum" of the first flow state and the result of this operation
 results in the second state.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.AccessVisitor.CreateSequenceFlow(System.Collections.Generic.List`1{System.Func`3{Flame.Optimization.Variables.IVariableDefinition,System.Boolean,Flame.Optimization.Variables.AccessMetrics}},System.Collections.Generic.List`1{System.Func`3{Flame.Optimization.Variables.IVariableDefinition,System.Boolean,Flame.Optimization.Variables.AccessMetrics}})">
      <summary>
 Creates a flow delta that represents the sequential execution of
 two flow deltas.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.AccessVisitor.CreateSelectFlow(System.Collections.Generic.List`1{System.Func`3{Flame.Optimization.Variables.IVariableDefinition,System.Boolean,Flame.Optimization.Variables.AccessMetrics}},System.Collections.Generic.List`1{System.Func`3{Flame.Optimization.Variables.IVariableDefinition,System.Boolean,Flame.Optimization.Variables.AccessMetrics}})">
      <summary>
 Creates a flow delta that represents selecting precisely one of two
 flow deltas.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.AccessVisitor.CreateLoopFlow(Flame.Compiler.UniqueTag,System.Collections.Generic.List`1{System.Func`3{Flame.Optimization.Variables.IVariableDefinition,System.Boolean,Flame.Optimization.Variables.AccessMetrics}})">
      <summary>
 Creates a flow delta that will be executed zero or more
 times.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.AccessVisitor.Visit(Flame.Compiler.IExpression)">
      <summary>
 "Visits" an expression: an expression is taken as input and transformed into another expression.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.AccessVisitor.Visit(Flame.Compiler.IStatement)">
      <summary>
 "Visits" a statement: an statement is taken as input and transformed into another statement.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.ConstantVariableDefinition">
      <summary>
 A variable definition that propagates a constant expression.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.ConstantVariableDefinition.#ctor(Flame.Compiler.IExpression)">
      <summary>
 Creates a new constant variable definition from the given expression.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.ConstantVariableDefinition.CreateGetExpression">
      <summary>
 Creates a get-expression for this constant variable definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.ConstantVariableDefinition.UseMetrics(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.AccessMetrics)">
      <summary>
 Has this variable definition "react" to definition access metrics.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.ConstantVariableDefinition.ReactTo(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Compiler.Statements.InsertStatement)">
      <summary>
 Has this variable definition "react" to a change in another definition's chain:
 it gets an opportunity to use the other variable's previous value.
 Either this variable definition reach or a newly created one is then returned.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.ConstantVariableDefinition.Variable">
      <summary>
 Gets this variable definition's underlying variable.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.CopyVariableDefinition">
      <summary>
 A variable definition that propagates a copy of another variable definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.CopyVariableDefinition.#ctor(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Optimization.Variables.VariableDefinitionChain,Flame.Compiler.IExpression)">
      <summary>
 Creates a new copy variable definition from the given arguments.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.CopyVariableDefinition.CreateGetExpression">
      <summary>
 Creates a get-expression for this copy variable definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.CopyVariableDefinition.UseMetrics(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.AccessMetrics)">
      <summary>
 Has this variable definition "react" to definition access metrics.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.CopyVariableDefinition.ReactTo(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Compiler.Statements.InsertStatement)">
      <summary>
 Has this variable definition "react" to a change in another definition's chain:
 it gets an opportunity to use the other variable's previous value.
 Either this variable definition reach or a newly created one is then returned.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.CopyVariableDefinition.Variable">
      <summary>
 Gets this variable definition's underlying variable.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.DefinitionPropagationPass">
      <summary>
 A pass that applies constant and copy propagation to statements.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.DefinitionPropagationPass.Apply(Flame.Compiler.IStatement)">
      <summary>
 Applies this pass to the given value.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.DependentVariableDefinition">
      <summary>
 A variable definition that propagates an expression provided that none of
 its dependencies have changed, and that the definition is propagated exactly
 once.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.DependentVariableDefinition.#ctor(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Optimization.Variables.PropagationDependencies,Flame.Compiler.IExpression,Flame.Compiler.Statements.InsertStatement)">
      <summary>
 Creates a new dependent variable definition from the given arguments.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.DependentVariableDefinition.CreateGetExpression">
      <summary>
 Creates a get-expression for this dependent variable definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.DependentVariableDefinition.UseMetrics(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.AccessMetrics)">
      <summary>
 Has this variable definition "react" to definition access metrics.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.DependentVariableDefinition.ReactTo(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Compiler.Statements.InsertStatement)">
      <summary>
 Has this variable definition "react" to a change in another definition's chain:
 it gets an opportunity to use the other variable's previous value.
 Either this variable definition reach or a newly created one is then returned.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.DependentVariableDefinition.Variable">
      <summary>
 Gets this variable definition's underlying variable.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.IDefinitionAccess">
      <summary>
 A unique identifier that represents a single variable access.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.IDefinitionAccess.GetLiveliness(System.Collections.Generic.HashSet`1{Flame.Optimization.Variables.VariableDefinitionReach})">
      <summary>
 Determines this definition access' liveliness, based on a set of
 variable definitions whose liveliness depend on the outcome of this method.
 Said set can is to deal with cyclic variable definition dependencies.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.IDefinitionAccess.IsVolatile">
      <summary>
 Tells if this definition access is volatile.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.IDefinitionAccessNode">
      <summary>
 Defines common functionality for nodes that access definitions.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.IDefinitionAccessNode.Chain">
      <summary>
 Gets the definition chain that is being accessed.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.IDefinitionAccessNode.Access">
      <summary>
 Gets this node's definition access.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.UnconditionalAccess">
      <summary>
 Represents unconditional variable access.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.UnconditionalAccess.#ctor">
      <summary>
 Creates a new unique access identifier.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.UnconditionalAccess.GetLiveliness(System.Collections.Generic.HashSet`1{Flame.Optimization.Variables.VariableDefinitionReach})">
      <summary>
 Determines this definition access' liveliness, based on a set of
 variable definitions whose liveliness depend on the outcome of this method.
 Said set can is to deal with cyclic variable definition dependencies.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.VolatileAccess">
      <summary>
 Represents unconditional volatile variable access.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VolatileAccess.#ctor">
      <summary>
 Creates a new unique access identifier.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VolatileAccess.GetLiveliness(System.Collections.Generic.HashSet`1{Flame.Optimization.Variables.VariableDefinitionReach})">
      <summary>
 Determines this definition access' liveliness, based on a set of
 variable definitions whose liveliness depend on the outcome of this method.
 Said set can is to deal with cyclic variable definition dependencies.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.ReachDependentAccess">
      <summary>
 Defines variable access that is live only if an associated variable
 definition is, too.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.ReachDependentAccess.#ctor(Flame.Optimization.Variables.VariableDefinitionReach)">
      <summary>
 Creates a variable access identifier based on the given reach.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.ReachDependentAccess.GetLiveliness(System.Collections.Generic.HashSet`1{Flame.Optimization.Variables.VariableDefinitionReach})">
      <summary>
 Determines this definition access' liveliness, based on a set of
 variable definitions whose liveliness depend on the outcome of this method.
 Said set can is to deal with cyclic variable definition dependencies.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.ReachDependentAccess.Reach">
      <summary>
 Gets the variable definition reach whose liveliness this definition
 access depends on.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.IVariableDefinition">
      <summary>
 Defines common functionality for variable definitions.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.IVariableDefinition.CreateGetExpression">
      <summary>
 Creates a get-expression for this variable definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.IVariableDefinition.UseMetrics(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.AccessMetrics)">
      <summary>
 Has this variable definition make use of definition access metrics.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.IVariableDefinition.ReactTo(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Compiler.Statements.InsertStatement)">
      <summary>
 Has this variable definition "react" to a change in another definition's chain:
 it gets an opportunity to use the other variable's previous value.
 Either this variable definition reach or a newly created one is then returned.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.IVariableDefinition.Variable">
      <summary>
 Gets this variable definition's underlying variable, if any.
 Otherwise, null.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.IVariableDefinitionStatement">
      <summary>
 Defines common functionality for statements that define a variable.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.IVariableDefinitionStatement.Definition">
      <summary>
 Gets the definition reach associated with this node.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.BlockTerminationPoint">
      <summary>
 Defines a termination point for a block, which ends the current iteration.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.IVariableFlow">
      <summary>
 Defines common functionality for variable flow structures.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.IVariableFlow.GetTerminationPoints(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Compiler.UniqueTag)">
      <summary>
 Gets all termination points for the given chain and tagged block.
 This method must be called after updating the chain's reach
 with this block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.IVariableFlow.UpdateReach(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionChain)">
      <summary>
 Updates the given variable reach, possibly using a pre-insert point.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.EmptyVariableFlow.GetTerminationPoints(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Compiler.UniqueTag)">
      <summary>
 Gets all termination points for the given chain and tagged block.
 This method must be called after updating the chain's reach
 with this block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.EmptyVariableFlow.UpdateReach(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionChain)">
      <summary>
 Updates the given variable reach, possibly using a pre-insert point.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionFlow.GetTerminationPoints(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Compiler.UniqueTag)">
      <summary>
 Gets all termination points for the given chain and tagged block.
 This method must be called after updating the chain's reach
 with this block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionFlow.UpdateReach(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionChain)">
      <summary>
 Updates the given variable reach, possibly using a pre-insert point.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableAccessFlow.GetTerminationPoints(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Compiler.UniqueTag)">
      <summary>
 Gets all termination points for the given chain and tagged block.
 This method must be called after updating the chain's reach
 with this block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableAccessFlow.UpdateReach(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionChain)">
      <summary>
 Updates the given variable reach, possibly using a pre-insert point.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.SequenceVariableFlow.GetTerminationPoints(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Compiler.UniqueTag)">
      <summary>
 Gets all termination points for the given chain and tagged block.
 This method must be called after updating the chain's reach
 with this block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.SequenceVariableFlow.UpdateReach(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionChain)">
      <summary>
 Updates the given variable reach, possibly using a pre-insert point.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.LocalVariableDefinition">
      <summary>
 Defines a type for local variable definitions.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.LocalVariableDefinition.#ctor(Flame.Compiler.IUnmanagedVariable)">
      <summary>
 Creates a new local variable definition from the given variable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.LocalVariableDefinition.CreateGetExpression">
      <summary>
 Creates a get-expression for this local variable definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.LocalVariableDefinition.UseMetrics(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.AccessMetrics)">
      <summary>
 Has this variable definition "react" to definition access metrics.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.LocalVariableDefinition.ReactTo(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Compiler.Statements.InsertStatement)">
      <summary>
 Has this variable definition "react" to a change in another definition's chain:
 it gets an opportunity to use the other variable's previous value.
 Either this variable definition reach or a newly created one is then returned.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.LocalVariableDefinition.Variable">
      <summary>
 Gets this variable definition's underlying variable.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.LocalVariableDescription">
      <summary>
 Defines a uniquely identified local variable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.LocalVariableDescription.#ctor(Flame.Compiler.IVariable)">
      <summary>
 Creates a new local variable description from the given variable and index.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.LocalVariableDescription.Type">
      <summary>
 Gets the local variable's type.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.LocalVariableDescription.IsArgument">
      <summary>
 Figures out whether this local variable is an argument.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.LocalVariableDescription.IsThis">
      <summary>
 Figures out whether this local variable is a `this` pointer.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.LocalVariableDescription.IsLocal">
      <summary>
 Figures out whether this local variable is a plain local, rather
 than an argument or `this` pointer.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.LocalVariableDescription.Variable">
      <summary>
 Gets the unerlying local variable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.LoopVariableFlow.GetTerminationPoints(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Compiler.UniqueTag)">
      <summary>
 Gets all termination points for the given chain and tagged block.
 This method must be called after updating the chain's reach
 with this block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.LoopVariableFlow.UpdateReach(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionChain)">
      <summary>
 Updates the given variable reach, possibly using a pre-insert point.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.PropagationMode">
      <summary>
 An enumeration of different propagation schemes.
 </summary>
    </member>
    <member name="F:Flame.Optimization.Variables.PropagationMode.Never">
      <summary>
 Never propagate a value.
 </summary>
    </member>
    <member name="F:Flame.Optimization.Variables.PropagationMode.Once">
      <summary>
 Propagate a value exactly once.
 </summary>
    </member>
    <member name="F:Flame.Optimization.Variables.PropagationMode.Always">
      <summary>
 Always propagate a value.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.PropagationDependencies">
      <summary>
 Defines a set of dependencies that can be used to decide whether
 a value should be propagated or not.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.PropagationDependencies.#ctor(Flame.Optimization.Variables.PropagationMode,System.Collections.Generic.IEnumerable`1{Flame.Optimization.Variables.LocalVariableDescription})">
      <summary>
 Creates propagation dependencies from the given propagation scheme
 and a set of dependencies.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.PropagationDependencies.DependsOn(Flame.Optimization.Variables.LocalVariableDescription)">
      <summary>
 Checks if these propagation dependencies include the given local.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.PropagationDependencies.ShouldMaterialize(Flame.Optimization.Variables.AccessCount)">
      <summary>
 Determines whether these propagation dependencies should be
 propagated, based on the propagation rules.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.PropagationDependencies.Union(Flame.Optimization.Variables.PropagationDependencies)">
      <summary>
 Takes the union of these dependencies with the given dependencies.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.PropagationDependencies.Dependencies">
      <summary>
 Gets these propagation dependencies' contents.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.PropagationDependencies.Mode">
      <summary>
 Gets these propagation dependencies' propagation scheme.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.SelectVariableFlow.GetTerminationPoints(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Compiler.UniqueTag)">
      <summary>
 Gets all termination points for the given chain and tagged block.
 This method must be called after updating the chain's reach
 with this block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.SelectVariableFlow.UpdateReach(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionChain)">
      <summary>
 Updates the given variable reach, possibly using a pre-insert point.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.TerminatedVariableFlow">
      <summary>
 Defines terminated variable flow: a flow state that represents terminated flow.
 This is mainly intended for unknown flow termination types, as it enforces
 extremely conservative behavior.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.TerminatedVariableFlow.GetTerminationPoints(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Compiler.UniqueTag)">
      <summary>
 Gets all termination points for the given chain and tagged block.
 This method must be called after updating the chain's reach
 with this block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.TerminatedVariableFlow.UpdateReach(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionChain)">
      <summary>
 Updates the given variable reach, possibly using a pre-insert point.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.TerminatedBlockVariableFlow">
      <summary>
 Defines terminated block variable flow: a "break" or "continue" statement.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.TerminatedBlockVariableFlow.GetTerminationPoints(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Compiler.UniqueTag)">
      <summary>
 Gets all termination points for the given chain and tagged block.
 This method must be called after updating the chain's reach
 with this block.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.TerminatedBlockVariableFlow.UpdateReach(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionChain)">
      <summary>
 Updates the given variable reach, possibly using a pre-insert point.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.TransferDefinitionStatement">
      <summary>
 A type of statement that represents a transfer of a chain's current definition to the
 backing variable of another. If both use the same backing variable,
 no action is taken.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.TransferDefinitionStatement.#ctor(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Optimization.Variables.IDefinitionAccess,Flame.Optimization.Variables.VariableDefinitionReach)">
      <summary>
 Creates a new variable definition transfer statement.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.TransferDefinitionStatement.Chain">
      <summary>
 Gets the variable definition chain whose value is taken.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.TransferDefinitionStatement.Access">
      <summary>
 Gets the definition access that represents taking the chain's value.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.TransferDefinitionStatement.Definition">
      <summary>
 Gets the variable definition reach this statement depends on.
 If this reach is live, the assignment is performed.
 Otherwise, nothing happens.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.VariableDefinitionChain">
      <summary>
 Defines a variable definition chain: a list of variable definitions
 and their reach.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionChain.AddDefinition(Flame.Optimization.Variables.VariableDefinitionReach)">
      <summary>
 Adds a variable definition - and its reach - to this chain.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionChain.GetDefinition(Flame.Optimization.Variables.IDefinitionAccess)">
      <summary>
 Gets the variable definition that is associated with the given access
 identifier, if any. Otherwise, null.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionChain.Type">
      <summary>
 Gets this variable definition chain's type.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionChain.Definitions">
      <summary>
 Gets a sequence representing the definitions that belong to this
 variable definition chain, as well as their range.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionChain.UsedVariables">
      <summary>
 Gets the set of all used variables in this chain.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionChain.MappedLocal">
      <summary>
 Gets the original local this definition chain is mapped to.
 This need not correspond to the variable this definition chain is currently
 associated with.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.VariableDefinitionReach">
      <summary>
 Represents the reach of a single variable definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionReach.#ctor(Flame.Optimization.Variables.IVariableDefinition,Flame.Optimization.Variables.LocalVariableDescription)">
      <summary>
 Creates a new variable definition reach structure for the given definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionReach.GetLiveliness(System.Collections.Generic.IEnumerable`1{Flame.Optimization.Variables.VariableDefinitionReach})">
      <summary>
 Determines this definition' liveliness, based on a set of
 variable definitions whose liveliness depend on the outcome of this method.
 Said set is used to deal with cyclic variable definition dependencies.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionReach.Contains(Flame.Optimization.Variables.IDefinitionAccess)">
      <summary>
 Tests whether the given identifier is within this variable definition's reach.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionReach.Add(Flame.Optimization.Variables.IDefinitionAccess)">
      <summary>
 Adds a single identifier to this variable definition's reach.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionReach.Add(System.Collections.Generic.IEnumerable`1{Flame.Optimization.Variables.IDefinitionAccess})">
      <summary>
 Adds a set of identifiers to this variable definition's reach.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionReach.Remove(Flame.Optimization.Variables.IDefinitionAccess)">
      <summary>
 Removes a single identifier from this variable definition's reach.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionReach.Remove(System.Collections.Generic.IEnumerable`1{Flame.Optimization.Variables.IDefinitionAccess})">
      <summary>
 Removes a set of identifiers from this variable definition's reach.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionReach.Transfer(Flame.Optimization.Variables.VariableDefinitionReach,System.Collections.Generic.IEnumerable`1{Flame.Optimization.Variables.IDefinitionAccess})">
      <summary>
 Transfers the given set of identifiers from this variable definition's
 reach to another's.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionReach.IsVolatile">
      <summary>
 Tests if this variable definition has been made volatile.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionReach.IsLive">
      <summary>
 Tests if this variable definition is live.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionReach.Definition">
      <summary>
 Gets the variable definition whose reach is represented.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionReach.MappedLocal">
      <summary>
 Gets the local this variable definition was originally mapped to.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionReach.Reach">
      <summary>
 Defines a set of identifiers that are within this variable definition's reach.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.VariableDefinitionStatement">
      <summary>
 A type of statement that represents an assignment associated with a single
 variable definition.
 The assignment remains live as long as the definition is live.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionStatement.#ctor(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Compiler.IExpression)">
      <summary>
 Creates a new variable definition statement from the given parameters.
 Note that the given definition must have an underlying variable.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionStatement.Definition">
      <summary>
 Gets the variable definition reach this statement depends on.
 If this reach is live, the assignment is performed.
 Otherwise, the assignment's right-hand side is simply popped.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionStatement.Value">
      <summary>
 Gets the right-hand side of the variable assignment operation.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.VariableDefinitionMarker">
      <summary>
 A type of statement that marks a variable's definition, but does not
 do anything beyond that.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionMarker.#ctor(Flame.Optimization.Variables.VariableDefinitionReach)">
      <summary>
 Creates a new variable definition marker statement.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionMarker.Definition">
      <summary>
 Gets the variable definition that is marked here.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionVisitor.#ctor">
      <summary>
 Creates a new final flow remover from the given enclosing flow
 and a function that matches final flow.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionVisitor.Id``1(T)">
      <summary>
 Identity helper function. For use as a delegate.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionVisitor.IsPropagateAlwaysTypeCore(Flame.IType)">
      <summary>
 Checks if the given type is a propagate-always type, which can
 safely be propagated anywhere.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionVisitor.IsPropagateAlwaysType(Flame.IType)">
      <summary>
 Checks if the given type is a propagate-always type, which can
 safely be propagated anywhere.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionVisitor.CreateCollapsedFlow(Flame.Optimization.Variables.VariableFlowState,Flame.Optimization.Variables.VariableFlowState(Flame.Optimization.Variables.VariableFlowState))">
      <summary>
 Computes the "sum" of a flow state and a control flow delta.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionVisitor.CreateDeltaFlow(Flame.Optimization.Variables.VariableFlowState,Flame.Optimization.Variables.VariableFlowState)">
      <summary>
 Computes the "difference" between two flow states, such that
 the "sum" of the first flow state and the result of this operation
 results in the second state.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionVisitor.CreateSequenceFlow(Flame.Optimization.Variables.VariableFlowState(Flame.Optimization.Variables.VariableFlowState),Flame.Optimization.Variables.VariableFlowState(Flame.Optimization.Variables.VariableFlowState))">
      <summary>
 Creates a flow delta that represents the sequential execution of
 two flow deltas.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionVisitor.CreateSelectFlow(Flame.Optimization.Variables.VariableFlowState(Flame.Optimization.Variables.VariableFlowState),Flame.Optimization.Variables.VariableFlowState(Flame.Optimization.Variables.VariableFlowState))">
      <summary>
 Creates a flow delta that represents selecting precisely one of two
 flow deltas.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionVisitor.CreateLoopFlow(Flame.Compiler.UniqueTag,Flame.Optimization.Variables.VariableFlowState(Flame.Optimization.Variables.VariableFlowState))">
      <summary>
 Creates a flow delta that will be executed zero or more
 times.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableDefinitionVisitor.GetDependencies(Flame.Compiler.IExpression)">
      <summary>
 Extracts propagation dependencies from this value.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionVisitor.TerminatedFlow">
      <summary>
 Gets a flow delta that represents flow termination:
 sequential flow that succeeds it will never be executed.
 </summary>
      <remarks>
 Terminated flow basically materializes everything.
 </remarks>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionVisitor.TerminatedGlobalFlow">
      <summary>
 Gets a flow delta that represents global flow termination:
 this signifies the end of this function call.
 </summary>
      <remarks>
 This really just does nothing at all, because we really don't
 care about what happens after this.
 </remarks>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableDefinitionVisitor.CurrentFlow">
      <summary>
 Gets or sets the current flow state.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowHelpers.Succeed(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Compiler.Statements.InsertStatement)">
      <summary>
 Creates a variable definition that "succeeds" the old variable definition.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowHelpers.Transfer(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Compiler.Statements.InsertStatement)">
      <summary>
 "Transfers" the old variable definition's value to the new one.
 Both definition reaches are registered with the definition chain.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowHelpers.Materialize(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Compiler.Statements.InsertStatement)">
      <summary>
 "Materializes" the given variable definition, using an insertion point.
 If the given variable definition has an underlying variable, it
 is returned unchanged. Otherwise, a new variable definition is returned that
 does contain an underlying variable, with the previous definition's
 value.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowHelpers.MakeVolatile(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Compiler.Statements.InsertStatement)">
      <summary>
 Marks the given variable definition as volatile.
 This will disable most, if not all, optimizations.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowHelpers.Phi(Flame.Optimization.Variables.VariableDefinitionChain,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Compiler.Statements.InsertStatement,Flame.Optimization.Variables.VariableDefinitionReach,Flame.Compiler.Statements.InsertStatement)">
      <summary>
 Selects one of two variable definitions. If the given variable definitions
 are the same definition, said variable definition is returned.
 Otherwise, a both are assigned to a variable, and a variable definition
 is returned that wraps that variable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowHelpers.CreateLocal(Flame.Optimization.Variables.VariableDefinitionReach)">
      <summary>
 Creates or retrieves a local variable to use as this variable definition
 reach's backing storage.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowHelpers.CreateLocal(Flame.Optimization.Variables.LocalVariableDescription)">
      <summary>
 Creates or retrieves a local variable that is equal to or of the
 same type as the given described local variable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowHelpers.CreatePhiLocal(Flame.Optimization.Variables.VariableDefinitionReach,Flame.Optimization.Variables.VariableDefinitionReach)">
      <summary>
 Creates or retrieves a local variable to use as the backing storage for
 the new phi definition for these variables.
 These definitions should represent the same original local variable.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowHelpers.CreatePhiLocal(Flame.Optimization.Variables.LocalVariableDescription,System.Collections.Generic.IEnumerable`1{Flame.Optimization.Variables.VariableDefinitionReach})">
      <summary>
 Creates or retrieves a local variable to use as the backing storage for
 the new phi definition for these variables.
 These definitions should represent the same original local variable.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.VariableFlowNode">
      <summary>
 A type of node that describes variable flow.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.VariableFlowState">
      <summary>
 Defines a variable flow state, which is a singly linked list of
 sequential variable flow bodies.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowState.AsCons">
      <summary>
 Casts this variable flow state to a nonempty variable flow state.
 Please use this alongside `IsCons`.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowState.ToFlow">
      <summary>
 Converts this variable flow state to sequential flow.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowState.Cons(Flame.Optimization.Variables.VariableFlowNode)">
      <summary>
 Creates a new nonempty flow state by "appending" the given
 node to this flow state.
 No state is mutated.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.VariableFlowState.Concat(Flame.Optimization.Variables.VariableFlowState)">
      <summary>
 Concatenates two variable flow states.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableFlowState.IsCons">
      <summary>
 Tests if this variable flow state is nonempty.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableFlowState.IsNil">
      <summary>
 Tests if this variable flow state is empty.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.VariableFlowState.PostInsert">
      <summary>
 Returns the insert point directly after the variable flow state's body.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.NilVariableFlowState">
      <summary>
 An empty variable flow state.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.NilVariableFlowState.ToFlow">
      <summary>
 Converts this variable flow state to sequential flow.
 </summary>
    </member>
    <member name="T:Flame.Optimization.Variables.ConsVariableFlowState">
      <summary>
 A nonempty variable flow state.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.ConsVariableFlowState.ToFlow">
      <summary>
 Converts this variable flow state to sequential flow.
 </summary>
    </member>
    <member name="P:Flame.Optimization.Variables.AccessCount.Static_Singleton.Infinity">
      <summary>
 Gets an access count that represents an infinite number of accesses.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.PropagationDependencies.Static_Singleton.Single(Flame.Optimization.Variables.PropagationMode,Flame.Optimization.Variables.LocalVariableDescription)">
      <summary>
 Gets propagation dependencies that depend on a single local,
 propagated as per the given propagation scheme.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.PropagationDependencies.Static_Singleton.None(Flame.Optimization.Variables.PropagationMode)">
      <summary>
 Gets propagation "dependencies" that do not depend on any locals,
 but do use the given dependency scheme.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.PropagationDependencies.Static_Singleton.Always(Flame.Optimization.Variables.LocalVariableDescription)">
      <summary>
 Gets propagation dependencies that represent the perpetual propagation
 of a value, given that the the argument's definition does not change.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.PropagationDependencies.Static_Singleton.Always">
      <summary>
 Gets propagation dependencies that represent the perpetual propagation
 of a value, irrespective of changes to variables.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.PropagationDependencies.Static_Singleton.Once(Flame.Optimization.Variables.LocalVariableDescription)">
      <summary>
 Gets propagation dependencies that represent a single propagation
 of a value, given that the the argument's definition does not change.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.PropagationDependencies.Static_Singleton.Once">
      <summary>
 Gets propagation dependencies that represent a single propagation
 of a value, irrespective of changes to variables.
 </summary>
    </member>
    <member name="M:Flame.Optimization.Variables.PropagationDependencies.Static_Singleton.Never">
      <summary>
 Gets propagation dependencies that bar any form of propagation.
 </summary>
    </member>
    <member name="M:Flame.Optimization.AccessChecker.Static_Singleton.CanAccess(Flame.IType,Flame.Compiler.IStatement)">
      <summary>
 Determines whether the given type can access all types and members
 that are referenced by the given statement.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SpeculativeFlowState.Static_Singleton.TerminatedFlow">
      <summary>
 Gets a speculative flow state that represents terminated flow.
 </summary>
    </member>
    <member name="P:Flame.Optimization.SpeculativeFlowState.Static_Singleton.InitialFlow">
      <summary>
 Gets a speculative flow state that represents initial flow.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InitialFlowState.Static_Singleton.TerminatedFlow">
      <summary>
 Gets an initial flow state that represents terminated flow.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InitialFlowState.Static_Singleton.InitialFlow">
      <summary>
 Gets an initial flow state that represents initial flow.
 </summary>
    </member>
    <member name="P:Flame.Optimization.InitialFlowState.Static_Singleton.NonInitialFlow">
      <summary>
 Gets an initial flow state that represents non-initial flow.
 </summary>
    </member>
    <member name="M:Flame.Optimization.SizeVisitor.Static_Singleton.ApproximateSize(Flame.Compiler.IStatement,System.Boolean,System.Int32)">
      <summary>
 Approximates the given statement's size, based on the given parameters.
 </summary>
    </member>
  </members>
</doc>